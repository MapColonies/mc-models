import 'reflect-metadata';
import { IDescribeTsType } from '../../../layerMetadata';
import { IFieldConfigClassInfo } from './classFieldConfig.decorator';

const fieldConfigMetadataKey = Symbol('fieldconfig');

export interface IValidationConfigInfoMapping {
  validation?: IValidationConfigInfo[];
}

export enum FieldCategory {
  MAIN = 'MAIN',
  GENERAL = 'GENERAL',
  GEO_INFO = 'GEO_INFO',
}
export interface IValidationConfigInfo {
  errorMsgCode: string;
  valueType?: 'value' | 'field';
  min?: number | string | '$NOW';
  max?: number | string | '$NOW';
  minLength?: number;
  maxLength?: number;
  pattern?: string;
  required?: boolean;
  json?: boolean;
}

export interface IFieldConfigInfo {
  category: FieldCategory; // field category
  complexType?: IDescribeTsType; // complex type subfields
  subFields?: IFieldConfigClassInfo; // complex type subfields
  isManuallyEditable?: boolean; // is field can be modified via form after ingestion.
  isFilterable?: boolean; // is field might participate in filter/search params
  isSortable?: boolean; // is field might participate in sorting
  isRequired?: boolean; // is field mandatory, deprecated should be implemeted by validation type='required'
  isAutoGenerated?: boolean; // is field non relevant as input field for ingestion, but should be presented as a part of the model.
  isLifecycleEnvolved?: boolean; // is field might be changed during external processes, outside of the app's form.
  isCreateEssential?: boolean; // is field should participate in create process
  isUpdateEssential?: boolean; // is field should participate in update process
  isMultiSelection?: boolean; // is multi selection field
  lookupTable?: string; // lookup table name where from comes allowed values (should participate in server-side validations)
  autocomplete?: {
    type: 'domain' | 'service';
    value: string;
  };
  infoMsgCode?: string[];
  validation?: IValidationConfigInfo[];
  default?: string | number;
  shapeFileMapping?: string;
}

export interface IPropFieldConfigInfo extends IFieldConfigInfo {
  prop: string;
  validation?: IValidationConfigInfo[];
}

export function fieldConfig(fieldConfigInfo: IFieldConfigInfo): PropertyDecorator {
  return Reflect.metadata(fieldConfigMetadataKey, fieldConfigInfo);
}

export function getFieldConfig<T>(target: T, propertyKey: string): IFieldConfigInfo | undefined {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //@ts-ignore
  return Reflect.getMetadata(fieldConfigMetadataKey, target, propertyKey) as IFieldConfigInfo;
}
