import { Polygon } from 'geojson';
import { keys } from 'ts-transformer-keys';
import { graphql } from '../common/decorators/graphQL/graphql.decorator';
import { FieldCategory, IPropFieldConfigInfo, fieldConfig, getFieldConfig } from '../common/decorators/fieldConfig/fieldConfig.decorator';
import { DataFileType, IPropSHPMapping, getInputDataMapping, inputDataMapping } from '../layerMetadata/decorators/property/shp.decorator';
import { catalogDB, getCatalogDBMapping } from '../layerMetadata/decorators/property/catalogDB.decorator';
import { getTsTypesMapping, tsTypes, TsTypes } from '../layerMetadata/decorators/property/tsTypes.decorator';
import { ICatalogDBEntityMapping, IOrmCatalog, IPYCSWMapping, ProductType } from '../layerMetadata';
import { getWFSMapping, graphqlClass, IPropCatalogDBMapping, IPropWFSMapping, JAVA_BINDINGS, wfs } from '../common';
import { catalogDBEntity, getCatalogDBEntityMapping } from '../layerMetadata/decorators/class/catalogDBEntity.decorator';
import { VALIDATIONS } from '../raster/constants';

interface IPropPYCSWMapping extends IPYCSWMapping {
  prop: string;
}

const POLYGON_PARTS_KEYS = keys<IPolygonPart>();
const POLYGON_PARTS_SERVED_KEYS =
  keys<Omit<IPolygonPart, 'productId' | 'productType' | 'id' | 'catalogId' | 'productVersion' | 'ingestionDateUTC' | 'partId'>>();

@catalogDBEntity({
  table: 'PPRecordsPartial',
  className: 'PolygonPartRecord',
})
@graphqlClass({ alias: 'PolygonPartRecord', fields: POLYGON_PARTS_KEYS })
export class PolygonPartRecord implements IPolygonPart, IOrmCatalog {
  //#region METADATA: sourceId
  @catalogDB({
    column: {
      name: 'source_id',
      type: 'text',
      nullable: true,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.STRING,
  })
  @inputDataMapping({
    dataFile: DataFileType.SHAPE_METADATA,
    valuePath: 'properties.Source',
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.MAIN,
  })
  //#endregion
  public sourceId?: string;

  //#region METADATA: sourceName
  @catalogDB({
    column: {
      name: 'source_name',
      type: 'text',
      nullable: false,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.STRING,
  })
  @inputDataMapping({
    dataFile: DataFileType.SHAPE_METADATA,
    valuePath: 'properties.SourceName',
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.MAIN,
    infoMsgCode: ['info-general-tooltip.required'],
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
    ],
  })
  //#endregion
  public sourceName!: string;

  //#region METADATA: productId
  @catalogDB({
    column: {
      name: 'product_id',
      type: 'text',
      nullable: false,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.STRING,
  })
  @inputDataMapping({
    dataFile: DataFileType.SHAPE_METADATA,
    valuePath: 'properties.SourceName',
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.MAIN,
    isAutoGenerated: true,
    infoMsgCode: ['info-field-tooltip.productId.pattern'],
    validation: [
      {
        errorMsgCode: 'validation-field.productId.pattern',
        valueType: 'value',
        pattern: VALIDATIONS.productId.pattern,
      },
    ],
  })
  //#endregion
  public productId!: string;

  //#region METADATA: productType
  @catalogDB({
    column: {
      name: 'product_type',
      type: 'text',
      nullable: false,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.STRING,
  })
  @tsTypes({
    mappingType: TsTypes.PRODUCTTYPE,
  })
  @fieldConfig({
    category: FieldCategory.MAIN,
    isAutoGenerated: true,
  })
  //#endregion
  public productType!: ProductType;

  //#region METADATA: description
  @catalogDB({
    column: {
      name: 'description',
      type: 'text',
      nullable: true,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.STRING,
  })
  @inputDataMapping({
    dataFile: DataFileType.SHAPE_METADATA,
    valuePath: 'properties.Dsc',
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql({
    nullable: true,
  })
  @fieldConfig({
    category: FieldCategory.GENERAL,
  })
  //#endregion
  public description?: string;

  //#region METADATA: imagingTimeBeginUTC
  @catalogDB({
    column: {
      name: 'imaging_time_begin_utc',
      type: 'timestamp with time zone',
      nullable: false,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.TIMESTAMP,
  })
  @inputDataMapping({
    isCustomLogic: false,
    dataFile: DataFileType.SHAPE_METADATA,
    valuePath: 'properties.UpdateDate',
  })
  @tsTypes({
    mappingType: TsTypes.DATE,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.GENERAL,
    infoMsgCode: ['info-general-tooltip.required', 'info-field-tooltip.sourceDateStart.max'],
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
      {
        errorMsgCode: 'validation-field.sourceDateStart.max',
        valueType: 'field',
        max: 'imagingTimeEndUTC',
      },
    ],
  })
  //#endregion
  public imagingTimeBeginUTC!: Date;

  //#region METADATA: imagingTimeEndUTC
  @catalogDB({
    column: {
      name: 'imaging_time_end_utc',
      type: 'timestamp with time zone',
      nullable: false,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.TIMESTAMP,
  })
  @inputDataMapping({
    isCustomLogic: false,
    dataFile: DataFileType.SHAPE_METADATA,
    valuePath: 'properties.UpdateDate',
  })
  @tsTypes({
    mappingType: TsTypes.DATE,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.GENERAL,
    infoMsgCode: ['info-general-tooltip.required'],
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
    ],
  })
  //#endregion
  public imagingTimeEndUTC!: Date;

  //#region METADATA: horizontalAccuracyCE90
  @catalogDB({
    column: {
      name: 'horizontal_accuracy_ce_90',
      type: 'real',
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.FLOAT,
  })
  @inputDataMapping({
    dataFile: DataFileType.SHAPE_METADATA,
    valuePath: 'properties.Ep90',
  })
  @tsTypes({
    mappingType: TsTypes.NUMBER,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.GEO_INFO,
    infoMsgCode: ['info-general-tooltip.required'],
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
      {
        errorMsgCode: 'validation-field.minHorizontalAccuracyCE90.min',
        valueType: 'value',
        min: VALIDATIONS.horizontalAccuracyCE90.min,
      },
      {
        errorMsgCode: 'validation-field.minHorizontalAccuracyCE90.max',
        valueType: 'value',
        max: VALIDATIONS.horizontalAccuracyCE90.max,
      },
    ],
  })
  //#endregion
  public horizontalAccuracyCE90!: number;

  //#region METADATA: sensors
  @catalogDB({
    column: {
      name: 'sensors',
      type: 'text',
      nullable: false,
    },
    field: {
      overrideType: TsTypes.STRING,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.STRING,
  })
  @inputDataMapping({
    isCustomLogic: false,
    dataFile: DataFileType.SHAPE_METADATA,
    valuePath: 'properties.SensorType',
  })
  @tsTypes({
    mappingType: TsTypes.STRING_ARRAY,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.GENERAL,
    infoMsgCode: ['info-field-tooltip.sensors.tooltip', 'info-general-tooltip.required'],
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
    ],
  })
  //#endregion
  public sensors!: string[];

  //#region METADATA: countries
  @catalogDB({
    column: {
      name: 'countries',
      type: 'text',
      nullable: true,
    },
    field: {
      overrideType: TsTypes.STRING,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.STRING,
  })
  @inputDataMapping({
    isCustomLogic: false,
    dataFile: DataFileType.SHAPE_METADATA,
    valuePath: 'properties.Countries',
  })
  @tsTypes({
    mappingType: TsTypes.STRING_ARRAY,
  })
  @graphql({
    nullable: true,
  })
  @fieldConfig({
    category: FieldCategory.GENERAL,
    infoMsgCode: ['info-field-tooltip.region.tooltip'],
  })
  //#endregion
  public countries?: string[];

  //#region **TO_VERIFY_CITIES?** METADATA: cities
  @catalogDB({
    column: {
      name: 'cities',
      type: 'text',
      nullable: true,
    },
    field: {
      overrideType: TsTypes.STRING,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.STRING,
  })
  @inputDataMapping({
    isCustomLogic: false,
    dataFile: DataFileType.SHAPE_METADATA,
    valuePath: 'properties.Cities',
  })
  @tsTypes({
    mappingType: TsTypes.STRING_ARRAY,
  })
  @graphql({
    nullable: true,
  })
  @fieldConfig({
    category: FieldCategory.GENERAL,
  })
  //#endregion
  public cities?: string[];

  //#region METADATA: resolutionDegree??? [from INGESTION PARAMS]
  @catalogDB({
    column: {
      name: 'resolution_degree',
      type: 'numeric',
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.BIGDECIMAL,
  })
  @tsTypes({
    mappingType: TsTypes.NUMBER,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.MAIN,
    isAutoGenerated: true,
    infoMsgCode: [
      'info-field-tooltip.maxResolutionDeg.tooltip',
      'info-general-tooltip.required',
      'info-field-tooltip.maxResolutionDeg.min',
      'info-field-tooltip.maxResolutionDeg.max',
    ],
    validation: [
      {
        errorMsgCode: 'validation-field.maxResolutionDeg.min',
        valueType: 'value',
        min: VALIDATIONS.resolutionDeg.min,
      },
      {
        errorMsgCode: 'validation-field.maxResolutionDeg.max',
        valueType: 'value',
        max: VALIDATIONS.resolutionDeg.max,
      },
    ],
  })
  //#endregion
  public resolutionDegree!: number;

  //#region METADATA: resolutionMeter [from INGESTION PARAMS]
  @catalogDB({
    column: {
      name: 'resolution_meter',
      type: 'numeric',
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.BIGDECIMAL,
  })
  @tsTypes({
    mappingType: TsTypes.NUMBER,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.MAIN,
    infoMsgCode: ['info-general-tooltip.required', 'info-field-tooltip.maxResolutionMeter.min', 'info-field-tooltip.maxResolutionMeter.max'],
    isAutoGenerated: true,
    validation: [
      {
        errorMsgCode: 'validation-field.maxResolutionMeter.min',
        valueType: 'value',
        min: VALIDATIONS.resolutionMeter.min,
      },
      {
        errorMsgCode: 'validation-field.maxResolutionMeter.max',
        valueType: 'value',
        max: VALIDATIONS.resolutionMeter.max,
      },
    ],
  })
  //#endregion
  public resolutionMeter!: number;

  //#region METADATA: sourceResolutionMeter [READONLY]
  @catalogDB({
    column: {
      name: 'source_resolution_meter',
      type: 'numeric',
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.BIGDECIMAL,
  })
  @tsTypes({
    mappingType: TsTypes.NUMBER,
  })
  @inputDataMapping({
    dataFile: DataFileType.SHAPE_METADATA,
    valuePath: 'properties.Resolution',
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.MAIN,
    infoMsgCode: ['info-general-tooltip.required'],
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
    ],
  })
  //#endregion
  public sourceResolutionMeter!: number;

  //#region METADATA: footprint
  @catalogDB({
    column: {
      name: 'footprint',
      type: 'text',
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.POLYGON,
  })
  @inputDataMapping({
    dataFile: DataFileType.PRODUCT,
    valuePath: 'geometry',
  })
  @tsTypes({
    mappingType: TsTypes.OBJECT,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.GEO_INFO,
    infoMsgCode: ['info-general-tooltip.required'],
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
      {
        errorMsgCode: 'validation-field.footprint.json',
        json: true,
      },
    ],
  })
  //#endregion
  public footprint!: Polygon;

  //#region RECORD: id
  @catalogDB({
    column: {
      name: 'id',
      type: 'text',
      nullable: false,
      primary: true,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.UUID,
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @fieldConfig({
    category: FieldCategory.MAIN,
    isAutoGenerated: true,
  })
  //#endregion
  public id!: string;

  //#region RECORD: partId
  @catalogDB({
    column: {
      name: 'part_id',
      type: 'number',
      nullable: false,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.UUID,
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.MAIN,
    isAutoGenerated: true,
  })
  //#endregion
  public partId!: string;

  //#region RECORD: catalogId
  @catalogDB({
    column: {
      name: 'catalog_id',
      type: 'text',
      nullable: false,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.UUID,
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @fieldConfig({
    category: FieldCategory.MAIN,
    isAutoGenerated: true,
  })
  //#endregion
  public catalogId!: string;

  //#region RECORD: productVersion [Version number of the best layer when it was updated]
  @catalogDB({
    column: {
      name: 'product_version',
      type: 'text',
      nullable: false,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.STRING,
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @fieldConfig({
    category: FieldCategory.MAIN,
    infoMsgCode: ['info-field-tooltip.productVersion.pattern'],
    isAutoGenerated: true,
    validation: [
      {
        errorMsgCode: 'validation-field.productVersion.pattern',
        valueType: 'value',
        pattern: VALIDATIONS.productVersion.pattern,
      },
    ],
  })
  //#endregion
  public productVersion!: string;

  //#region RECORD: ingestionDateUTC
  @catalogDB({
    column: {
      name: 'ingestion_date_utc',
      type: 'timestamp with time zone',
      nullable: false,
    },
  })
  @wfs({
    binding: JAVA_BINDINGS.TIMESTAMP,
  })
  @tsTypes({
    mappingType: TsTypes.DATE,
  })
  @fieldConfig({
    category: FieldCategory.MAIN,
    isAutoGenerated: true,
  })
  //#endregion
  public ingestionDateUTC!: Date;

  public static getPyCSWMappings(): IPropPYCSWMapping[] {
    return [];
  }

  public static getWFSMappings(): IPropWFSMapping[] {
    const ret: IPropWFSMapping[] = [];
    const layer = new PolygonPartRecord();
    POLYGON_PARTS_SERVED_KEYS.forEach((prop) => {
      const catalogDbMap = getCatalogDBMapping(layer, prop);
      const wfsMap = getWFSMapping<PolygonPartRecord>(layer, prop);
      if (catalogDbMap && wfsMap) {
        const { name, ...rest } = wfsMap;
        ret.push({
          prop: prop,
          name: name ?? prop,
          source: catalogDbMap.column.name as string,
          nillable: catalogDbMap.column.nullable ?? false,
          ...rest,
        });
      }
    });
    return ret;
  }

  public static getShpMappings(includeCustomLogic = false): IPropSHPMapping[] {
    const ret: IPropSHPMapping[] = [];
    const layer = new PolygonPartRecord();
    POLYGON_PARTS_SERVED_KEYS.forEach((prop) => {
      const shpMap = getInputDataMapping<PolygonPartRecord>(layer, prop);
      const tsTypesMap = getTsTypesMapping<PolygonPartRecord>(layer, prop);
      if (shpMap && tsTypesMap && (includeCustomLogic || shpMap.isCustomLogic === undefined || !shpMap.isCustomLogic)) {
        ret.push({
          prop: prop,
          ...shpMap,
          ...tsTypesMap,
        });
      }
    });
    return ret;
  }

  public static getFieldConfigs(): IPropFieldConfigInfo[] {
    const ret: IPropFieldConfigInfo[] = [];
    const layer = new PolygonPartRecord();
    POLYGON_PARTS_SERVED_KEYS.forEach((prop) => {
      const fieldConfigMap = getFieldConfig<PolygonPartRecord>(layer, prop);
      if (fieldConfigMap) {
        ret.push({
          prop: prop,
          ...fieldConfigMap,
        });
      }
    });
    return ret;
  }

  public getORMCatalogMappings(): IPropCatalogDBMapping[] {
    const ret: IPropCatalogDBMapping[] = [];

    const layer = new PolygonPartRecord();
    POLYGON_PARTS_KEYS.forEach((prop) => {
      const catalogDbMap = getCatalogDBMapping(layer, prop);
      const tsTypesMap = getTsTypesMapping(layer, prop);
      if (catalogDbMap && tsTypesMap) {
        ret.push({
          prop: prop,
          ...catalogDbMap,
          ...tsTypesMap,
        });
      }
    });
    return ret;
  }

  public getORMCatalogEntityMappings(): ICatalogDBEntityMapping {
    return getCatalogDBEntityMapping(PolygonPartRecord);
  }
}

export interface IPolygonPart {
  id: string;
  partId: string;
  catalogId: string;
  productId: string;
  productVersion: string;
  productType: ProductType;
  sourceId?: string;
  sourceName: string;
  description?: string;
  resolutionDegree: number;
  resolutionMeter: number;
  sourceResolutionMeter: number;
  horizontalAccuracyCE90: number;
  countries?: string[];
  cities?: string[];
  sensors: string[];
  imagingTimeBeginUTC: Date;
  imagingTimeEndUTC: Date;
  ingestionDateUTC: Date;
  footprint: Polygon;
}
