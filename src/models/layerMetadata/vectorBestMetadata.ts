import { GeoJSON } from 'geojson';
import { RecordType, ProductType } from '@map-colonies/types';
import { graphql } from '../common/decorators/graphQL/graphql.decorator';
import {
  FieldCategory,
  fieldConfig,
  getFieldConfig,
  IFieldConfigInfo,
  IPropFieldConfigInfo,
} from '../common/decorators/fieldConfig/fieldConfig.decorator';
import { tsTypes, TsTypes } from './decorators/property/tsTypes.decorator';
import { IPropSHPMapping } from './decorators/property/shp.decorator';
import { getWFSMapping, graphqlClass, IPropWFSMapping, IWFSMapping, Link, wfs } from '../common';
import { getFieldConfigClassInfo } from '../common/decorators/fieldConfig/classFieldConfig.decorator';
import { IPropPYCSWMapping } from './layerRASTERMetadata';
import { VectorFeatureTypeStructure } from './vectorFeatureTypeStructure';

export interface IVectorBestMetadata {
  id: string | undefined;
  keywords: string | undefined;
  links: Link[] | undefined;
  type: RecordType | undefined;
  classification: string | undefined;
  productName: string | undefined;
  description: string | undefined;
  srsId: string | undefined;
  srsName: string | undefined;
  producerName: string | undefined;
  footprint: GeoJSON | undefined;
  productType: ProductType | undefined;
  featureStructure: VectorFeatureTypeStructure | undefined;
}

@graphqlClass({ alias: 'VectorBestRecord' })
export class VectorBestMetadata implements IVectorBestMetadata {
  //#region COMMON FIELDS

  //#region CORE: id
  @wfs({
    capabilitiesMapping: {
      xmlElement: '',
    },
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.MAIN,
    isAutoGenerated: true,
  })
  //#endregion
  public id: string | undefined = undefined;

  //#region CORE: keywords
  @wfs({
    capabilitiesMapping: {
      xmlElement: 'keywords',
    },
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql({
    nullable: true,
  })
  @fieldConfig({
    category: FieldCategory.GENERAL,
    isManuallyEditable: true,
  })
  //#endregion
  public keywords: string | undefined = undefined;

  //#region CORE: links
  @wfs({
    capabilitiesMapping: {
      xmlElement: 'name',
    },
  })
  @tsTypes({
    mappingType: TsTypes.LINKS,
  })
  @graphql({
    nullable: true,
  })
  @fieldConfig({
    category: FieldCategory.GENERAL,
    complexType: TsTypes.LINKS,
    isAutoGenerated: true,
  })
  //#endregion
  public links: Link[] | undefined = undefined;

  //#region COMMON: type
  @wfs({
    capabilitiesMapping: {
      xmlElement: '',
    },
  })
  @tsTypes({
    mappingType: TsTypes.RECORDTYPE,
  })
  @graphql({
    nullable: true,
  })
  //#endregion
  public type: RecordType | undefined = RecordType.RECORD_RASTER;

  //#region COMMON: classification
  @wfs({
    capabilitiesMapping: {
      xmlElement: '',
    },
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql({
    nullable: false,
  })
  @fieldConfig({
    category: FieldCategory.GENERAL,
    isAutoGenerated: false,
    isManuallyEditable: true,
    infoMsgCode: ['info-general-tooltip.required'],
    lookupTable: 'classification',
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
    ],
  })
  //#endregion
  public classification: string | undefined = undefined;

  //#region COMMON: productName
  @wfs({
    capabilitiesMapping: {
      xmlElement: 'name.localPart',
    },
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.MAIN,
    isManuallyEditable: true,
    infoMsgCode: ['info-general-tooltip.required'],
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
    ],
  })
  //#endregion
  public productName: string | undefined = undefined;

  //#region COMMON: description
  @wfs({
    capabilitiesMapping: {
      xmlElement: '',
    },
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql({
    nullable: true,
  })
  @fieldConfig({
    category: FieldCategory.GENERAL,
    isManuallyEditable: true,
  })
  //#endregion
  public description: string | undefined = undefined;

  //#region COMMON: srsId
  @wfs({
    capabilitiesMapping: {
      xmlElement: 'defaultCRS',
    },
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql({
    nullable: false,
  })
  @fieldConfig({
    category: FieldCategory.GEO_INFO,
    isAutoGenerated: true,
    default: '4326',
  })
  //#endregion
  public srsId: string | undefined = undefined;

  //#region COMMON: producerName
  @wfs({
    capabilitiesMapping: {
      xmlElement: 'name',
    },
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql({
    nullable: false,
  })
  @fieldConfig({
    category: FieldCategory.GENERAL,
    isManuallyEditable: true,
    default: 'IDFMU',
    infoMsgCode: ['info-general-tooltip.required'],
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
    ],
  })
  //#endregion
  public producerName: string | undefined = undefined;

  //#region VECTOR_BEST: productType
  @wfs({
    capabilitiesMapping: {
      xmlElement: '',
    },
  })
  @tsTypes({
    mappingType: TsTypes.PRODUCTTYPE,
  })
  @graphql()
  @fieldConfig({
    category: FieldCategory.MAIN,
    isAutoGenerated: true,
  })
  //#endregion
  public productType: ProductType | undefined = ProductType.RASTER_VECTOR_BEST;

  //#region VECTOR_BEST: srsName
  @wfs({
    capabilitiesMapping: {
      xmlElement: 'defaultCRS',
    },
  })
  @tsTypes({
    mappingType: TsTypes.STRING,
  })
  @graphql({
    nullable: false,
  })
  @fieldConfig({
    category: FieldCategory.GEO_INFO,
    default: 'WGS84GEO',
    infoMsgCode: ['info-general-tooltip.required'],
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
    ],
  })
  //#endregion
  public srsName: string | undefined = undefined;

  //#region VECTOR_BEST: footprint
  @wfs({
    capabilitiesMapping: {
      xmlElement: 'wgs84BoundingBox',
    },
  })
  @tsTypes({
    mappingType: TsTypes.OBJECT,
  })
  @graphql({
    nullable: false,
  })
  @fieldConfig({
    category: FieldCategory.GEO_INFO,
    infoMsgCode: ['info-general-tooltip.required'],
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
      {
        errorMsgCode: 'validation-field.footprint.json',
        json: true,
      },
    ],
  })
  //#endregion
  public footprint: GeoJSON | undefined = undefined;

  //#region VECTOR_BEST: featureStructure
  @wfs({
    capabilitiesMapping: {
      xmlElement: 'metadataLink',
    },
  })
  @tsTypes({
    mappingType: TsTypes.FEATURESTRUCTURE,
  })
  @graphql({
    nullable: false,
  })
  @fieldConfig({
    category: FieldCategory.MAIN,
    infoMsgCode: ['info-general-tooltip.required'],
    validation: [
      {
        errorMsgCode: 'validation-general.required',
        required: true,
      },
      {
        errorMsgCode: 'validation-field.featureStructure.json',
        json: true,
      },
    ],
  })
  //#endregion
  public featureStructure: VectorFeatureTypeStructure | undefined = undefined;
  //#endregion

  public static getWFSMapping(prop: string): IWFSMapping | undefined {
    return getWFSMapping<VectorBestMetadata>(new VectorBestMetadata(), prop);
  }

  public static getFieldConfig(prop: string): IFieldConfigInfo | undefined {
    return getFieldConfig<VectorBestMetadata>(new VectorBestMetadata(), prop);
  }

  public static getPyCSWMappings(): IPropPYCSWMapping[] {
    throw new Error('NOT IMPLEMENTED');
  }

  public static getWFSMappings(): IPropWFSMapping[] {
    const ret = [];
    const layer = new VectorBestMetadata();
    for (const prop in layer) {
      const wfsMap = getWFSMapping<VectorBestMetadata>(layer, prop);
      if (wfsMap) {
        ret.push({
          prop: prop,
          ...wfsMap,
        });
      }
    }
    return ret;
  }

  public static getFieldConfigs(): IPropFieldConfigInfo[] {
    const ret = [];
    const layer = new VectorBestMetadata();
    for (const prop in layer) {
      const fieldConfigMap = getFieldConfig<VectorBestMetadata>(layer, prop);
      if (fieldConfigMap) {
        const fieldConfig = { prop: prop, ...fieldConfigMap };
        if (fieldConfigMap.complexType) {
          fieldConfig.subFields = getFieldConfigClassInfo(fieldConfigMap.complexType.value);
        }
        ret.push(fieldConfig);
      }
    }
    return ret;
  }

  public static getShpMappings(): IPropSHPMapping[] {
    return [];
  }
}
